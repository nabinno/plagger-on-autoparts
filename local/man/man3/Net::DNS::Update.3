.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::Update 3"
.TH Net::DNS::Update 3 "2014-05-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Net::DNS::Update \- Create a DNS update packet
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS;
.Ve
.PP
.Vb 1
\&    $update = new Net::DNS::Update( 'example.com', 'IN' );
.Ve
.PP
.Vb 2
\&    $update->push( prereq => nxrrset('foo.example.com. A') );
\&    $update->push( update => rr_add('foo.example.com. 86400 A 192.168.1.2') );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::DNS::Update is a subclass of Net::DNS::Packet, to be used for
making \s-1DNS\s0 dynamic updates.
.PP
Programmers should refer to \s-1RFC2136\s0 for dynamic update semantics.
.PP
\&\s-1WARNING:\s0  This code is still under development.	 Please use with
caution on production nameservers.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 3
\&    $update = new Net::DNS::Update;
\&    $update = new Net::DNS::Update( 'example.com' );
\&    $update = new Net::DNS::Update( 'example.com', 'HS' );
.Ve
.PP
Returns a Net::DNS::Update object suitable for performing a \s-1DNS\s0
dynamic update.	 Specifically, it creates a packet with the header
opcode set to \s-1UPDATE\s0 and the zone record type to \s-1SOA\s0 (per \s-1RFC\s0 2136,
Section 2.3).
.PP
Programs must use the \fIpush()\fR method to add RRs to the prerequisite,
update, and additional sections before performing the update.
.PP
Arguments are the zone name and the class.  If the zone is omitted,
the default domain will be taken from the resolver configuration.
If the class is omitted, it defaults to \s-1IN\s0.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The first example below shows a complete program;
subsequent examples show only the creation of the update packet .
.Sh "Add a new host"
.IX Subsection "Add a new host"
.Vb 1
\&    #!/usr/bin/perl
.Ve
.PP
.Vb 1
\&    use Net::DNS;
.Ve
.PP
.Vb 2
\&    # Create the update packet.
\&    my $update = new Net::DNS::Update('example.com');
.Ve
.PP
.Vb 2
\&    # Prerequisite is that no A records exist for the name.
\&    $update->push( pre => nxrrset('foo.example.com. A') );
.Ve
.PP
.Vb 3
\&    # Add two A records for the name.
\&    $update->push( update => rr_add('foo.example.com. 86400 A 192.168.1.2') );
\&    $update->push( update => rr_add('foo.example.com. 86400 A 172.16.3.4') );
.Ve
.PP
.Vb 3
\&    # Send the update to the zone's primary master.
\&    my $resolver = new Net::DNS::Resolver;
\&    $resolver->nameservers('primary-master.example.com');
.Ve
.PP
.Vb 1
\&    my $reply = $resolver->send($update);
.Ve
.PP
.Vb 10
\&    # Did it work?
\&    if ($reply) {
\&            if ( $reply->header->rcode eq 'NOERROR' ) {
\&                    print "Update succeeded\en";
\&            } else {
\&                    print 'Update failed: ', $reply->header->rcode, "\en";
\&            }
\&    } else {
\&            print 'Update failed: ', $resolver->errorstring, "\en";
\&    }
.Ve
.Sh "Add an \s-1MX\s0 record for a name that already exists"
.IX Subsection "Add an MX record for a name that already exists"
.Vb 3
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( prereq => yxdomain('example.com') );
\&    $update->push( update => rr_add('example.com MX 10 mailhost.example.com') );
.Ve
.Sh "Add a \s-1TXT\s0 record for a name that doesn't exist"
.IX Subsection "Add a TXT record for a name that doesn't exist"
.Vb 3
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( prereq => nxdomain('info.example.com') );
\&    $update->push( update => rr_add('info.example.com TXT "yabba dabba doo"') );
.Ve
.Sh "Delete all A records for a name"
.IX Subsection "Delete all A records for a name"
.Vb 3
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( prereq => yxrrset('foo.example.com A') );
\&    $update->push( update => rr_del('foo.example.com A') );
.Ve
.Sh "Delete all RRs for a name"
.IX Subsection "Delete all RRs for a name"
.Vb 3
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( prereq => yxdomain('byebye.example.com') );
\&    $update->push( update => rr_del('byebye.example.com') );
.Ve
.Sh "Perform a \s-1DNS\s0 update signed using a \s-1BIND\s0 private key file"
.IX Subsection "Perform a DNS update signed using a BIND private key file"
.Vb 5
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( update => rr_add('foo.example.com A 10.1.2.3') );
\&    $update->sign_tsig( "$dir/Khmac-sha512.example.com.+165+01018.private" );
\&    my $reply = $resolver->send( $update );
\&    $reply->verify( $update ) || die $reply->verifyerr;
.Ve
.Sh "Signing the \s-1DNS\s0 update using a \s-1BIND\s0 public key file"
.IX Subsection "Signing the DNS update using a BIND public key file"
.Vb 1
\&    $update->sign_tsig( "$dir/Khmac-sha512.example.com.+165+01018.key" );
.Ve
.Sh "Signing the \s-1DNS\s0 update using a customised \s-1TSIG\s0 record"
.IX Subsection "Signing the DNS update using a customised TSIG record"
.Vb 3
\&    $update->sign_tsig( "$dir/Khmac-sha512.example.com.+165+01018.private",
\&                        fudge => 60
\&                        );
.Ve
.Sh "Another way to sign a \s-1DNS\s0 update"
.IX Subsection "Another way to sign a DNS update"
.Vb 2
\&    my $key_name = 'tsig-key';
\&    my $key      = 'awwLOtRfpGE+rRKF2+DEiw==';
.Ve
.PP
.Vb 2
\&    my $tsig = new Net::DNS::RR("$key_name TSIG $key");
\&    $tsig->fudge(60);
.Ve
.PP
.Vb 3
\&    my $update = new Net::DNS::Update('example.com');
\&    $update->push( update     => rr_add('foo.example.com A 10.1.2.3') );
\&    $update->push( additional => $tsig );
.Ve
.SH "BUGS"
.IX Header "BUGS"
This code is still under development.  Please use with caution on
production nameservers.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2002 Michael Fuhr. 
.PP
Portions Copyright (c) 2002\-2004 Chris Reinhardt.
.PP
All rights reserved.  This program is free software; you may redistribute
it and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Packet, Net::DNS::Header,
Net::DNS::RR, Net::DNS::Resolver, \s-1RFC\s0 2136, \s-1RFC\s0 2845
