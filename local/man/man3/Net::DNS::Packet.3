.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::Packet 3"
.TH Net::DNS::Packet 3 "2014-05-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Net::DNS::Packet \- DNS protocol packet
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS::Packet;
.Ve
.PP
.Vb 1
\&    $query = new Net::DNS::Packet( 'example.com', 'MX', 'IN' );
.Ve
.PP
.Vb 1
\&    $reply = $resolver->send( $query );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Net::DNS::Packet object represents a \s-1DNS\s0 protocol packet.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 2
\&    $packet = new Net::DNS::Packet( 'example.com' );
\&    $packet = new Net::DNS::Packet( 'example.com', 'MX', 'IN' );
.Ve
.PP
.Vb 1
\&    $packet = new Net::DNS::Packet();
.Ve
.PP
If passed a domain, type, and class, \fInew()\fR creates a Net::DNS::Packet
object which is suitable for making a \s-1DNS\s0 query for the specified
information.  The type and class may be omitted; they default to A
and \s-1IN\s0.
.PP
If called with an empty argument list, \fInew()\fR creates an empty packet.
.PP
.Vb 2
\&    $packet = new Net::DNS::Packet( \e$data );
\&    $packet = new Net::DNS::Packet( \e$data, 1 );        # debug
.Ve
.PP
If passed a reference to a scalar containing \s-1DNS\s0 packet data, a new
packet object is created by decoding the data.
The optional second boolean argument enables debugging output.
.PP
Returns undef if unable to create a packet object.
.PP
Decoding errors, including data corruption and truncation, are
collected in the $@ ($EVAL_ERROR) variable.
.PP
.Vb 1
\&    ( $packet, $length ) = new Net::DNS::Packet( \e$data );
.Ve
.PP
If called in array context, returns a packet object and the number
of octets successfully decoded.
.PP
Note that the number of RRs in each section of the packet may differ
from the corresponding header value if the data has been truncated
or corrupted during transmission.
.Sh "data"
.IX Subsection "data"
.Vb 2
\&    $data = $packet->data;
\&    $data = $packet->data( $size );
.Ve
.PP
Returns the packet data in binary format, suitable for sending as a
query or update request to a nameserver.
.PP
Truncation may be specified using a non-zero optional size argument.
.Sh "header"
.IX Subsection "header"
.Vb 1
\&    $header = $packet->header;
.Ve
.PP
Constructor method which returns a Net::DNS::Header object which
represents the header section of the packet.
.Sh "\s-1EDNS\s0 extended header"
.IX Subsection "EDNS extended header"
.Vb 3
\&    $edns    = $packet->edns;
\&    $version = $edns->version;
\&    $size    = $edns->size;
.Ve
.PP
Auxilliary function \fIedns()\fR provides access to \s-1EDNS\s0 extensions.
.Sh "reply"
.IX Subsection "reply"
.Vb 1
\&    $reply = $query->reply( $UDPmax );
.Ve
.PP
Constructor method which returns a new reply packet.
.PP
The optional UDPsize argument is the maximum \s-1UDP\s0 packet size which
can be reassembled by the local network stack, and is advertised in
response to an \s-1EDNS\s0 query.
.Sh "question, zone"
.IX Subsection "question, zone"
.Vb 1
\&    @question = $packet->question;
.Ve
.PP
Returns a list of Net::DNS::Question objects representing the
question section of the packet.
.PP
In dynamic update packets, this section is known as \fIzone()\fR and
specifies the \s-1DNS\s0 zone to be updated.
.Sh "answer, pre, prerequisite"
.IX Subsection "answer, pre, prerequisite"
.Vb 1
\&    @answer = $packet->answer;
.Ve
.PP
Returns a list of Net::DNS::RR objects representing the answer
section of the packet.
.PP
In dynamic update packets, this section is known as \fIpre()\fR or
\&\fIprerequisite()\fR and specifies the RRs or RRsets which must or must
not preexist.
.Sh "authority, update"
.IX Subsection "authority, update"
.Vb 1
\&    @authority = $packet->authority;
.Ve
.PP
Returns a list of Net::DNS::RR objects representing the authority
section of the packet.
.PP
In dynamic update packets, this section is known as \fIupdate()\fR and
specifies the RRs or RRsets to be added or deleted.
.Sh "additional"
.IX Subsection "additional"
.Vb 1
\&    @additional = $packet->additional;
.Ve
.PP
Returns a list of Net::DNS::RR objects representing the additional
section of the packet.
.Sh "print"
.IX Subsection "print"
.Vb 1
\&    $packet->print;
.Ve
.PP
Prints the packet data on the standard output in an \s-1ASCII\s0 format
similar to that used in \s-1DNS\s0 zone files.
.Sh "string"
.IX Subsection "string"
.Vb 1
\&    print $packet->string;
.Ve
.PP
Returns a string representation of the packet.
.Sh "answerfrom"
.IX Subsection "answerfrom"
.Vb 1
\&    print "packet received from ", $packet->answerfrom, "\en";
.Ve
.PP
Returns the \s-1IP\s0 address from which this packet was received.
User-created packets will return undef for this method.
.Sh "answersize"
.IX Subsection "answersize"
.Vb 1
\&    print "packet size: ", $packet->answersize, " bytes\en";
.Ve
.PP
Returns the size of the packet in bytes as it was received from a
nameserver.  User-created packets will return undef for this method
(use length($packet\->data) instead).
.Sh "push"
.IX Subsection "push"
.Vb 3
\&    $ancount = $packet->push( prereq => $rr );
\&    $nscount = $packet->push( update => $rr );
\&    $arcount = $packet->push( additional => $rr );
.Ve
.PP
.Vb 2
\&    $nscount = $packet->push( update => $rr1, $rr2, $rr3 );
\&    $nscount = $packet->push( update => @rr );
.Ve
.PP
Adds RRs to the specified section of the packet.
.PP
Returns the number of resource records in the specified section.
.Sh "unique_push"
.IX Subsection "unique_push"
.Vb 3
\&    $ancount = $packet->unique_push( prereq => $rr );
\&    $nscount = $packet->unique_push( update => $rr );
\&    $arcount = $packet->unique_push( additional => $rr );
.Ve
.PP
.Vb 2
\&    $nscount = $packet->unique_push( update => $rr1, $rr2, $rr3 );
\&    $nscount = $packet->unique_push( update => @rr );
.Ve
.PP
Adds RRs to the specified section of the packet provided that the
RRs are not already present in the same section.
.PP
Returns the number of resource records in the specified section.
.Sh "pop"
.IX Subsection "pop"
.Vb 3
\&    my $rr = $packet->pop( 'pre' );
\&    my $rr = $packet->pop( 'update' );
\&    my $rr = $packet->pop( 'additional' );
.Ve
.PP
Removes a single \s-1RR\s0 from the specified section of the packet.
.Sh "sign_tsig"
.IX Subsection "sign_tsig"
.Vb 1
\&    $query = Net::DNS::Packet->new( 'www.example.com', 'A' );
.Ve
.PP
.Vb 3
\&    $query->sign_tsig( 'Khmac-sha512.example.+165+01018.private',
\&                        fudge => 60
\&                        );
.Ve
.PP
.Vb 1
\&    $reply = $res->send( $query );
.Ve
.PP
.Vb 1
\&    $reply->verify( $query ) || die $reply->verifyerr;
.Ve
.PP
Attaches a \s-1TSIG\s0 resource record object, which will be used to sign
the packet (see \s-1RFC\s0 2845).
.PP
The \s-1TSIG\s0 record can be customised by optional additional arguments to
\&\fIsign_tsig()\fR or by calling the appropriate Net::DNS::RR::TSIG methods.
.PP
If you wish to create a \s-1TSIG\s0 record using a non-standard algorithm,
you will have to create it yourself.  In all cases, the \s-1TSIG\s0 name
must uniquely identify the key shared between the parties, and the
algorithm name must identify the signing function to be used with the
specified key.
.PP
.Vb 6
\&    $tsig = Net::DNS::RR->new(  name            => 'tsig.example',
\&                                type            => 'TSIG',
\&                                algorithm       => 'custom-algorithm',
\&                                sig_function    => sub { ... },
\&                                key             => '<base64 key text>'
\&                                );
.Ve
.PP
.Vb 2
\&    $packet = Net::DNS::Packet->new( 'www.example.com', 'A' );
\&    $packet->sign_tsig( $tsig );
.Ve
.PP
The historical simplified syntax is still available, but additional
options can not be specified.
.PP
.Vb 1
\&    $packet->sign_tsig( $key_name, $key );
.Ve
.PP
The response to an inbound request is signed by presenting the request
in place of the key parameter.
    \f(CW$response\fR = \f(CW$request\fR\->reply;
    \f(CW$response\fR\->sign_tsig( \f(CW$request\fR, \f(CW@options\fR );
.PP
Multi-packet transactions are signed by chaining the \fIsign_tsig()\fR
calls together as follows:
.PP
.Vb 3
\&    $opaque  =  $packet1->sign_tsig( 'Kexample.+165+13281.private' );
\&    $opaque  =  $packet2->sign_tsig( $opaque );
\&                $packet3->sign_tsig( $opaque );
.Ve
.PP
The opaque intermediate object references returned during multi-packet
signing are not intended to be accessed by the end-user application.
Any such access is expressly forbidden.
.PP
Note that a \s-1TSIG\s0 record is added to every packet; the implementation
does not support the suppressed signature scheme described in \s-1RFC2845\s0.
.Sh "verify and verifyerr"
.IX Subsection "verify and verifyerr"
.Vb 2
\&    $packet->verify()           || die $packet->verifyerr;
\&    $reply->verify( $query )    || die $reply->verifyerr;
.Ve
.PP
Verify \s-1TSIG\s0 signature of packet or reply to the corresponding query.
.PP
.Vb 3
\&    $opaque  =  $packet1->verify( $query ) || die $packet1->verifyerr;
\&    $opaque  =  $packet2->verify( $opaque );
\&    $verifed =  $packet3->verify( $opaque ) || die $packet3->verifyerr;
.Ve
.PP
The opaque intermediate object references returned during multi-packet
\&\fIverify()\fR will be undefined (Boolean false) if verification fails.
Access to the object itself, if it exists, is expressly forbidden.
Testing at every stage may be omitted, which results in a \s-1BADSIG\s0 error
on the final packet in the absence of more specific information.
.Sh "sign_sig0"
.IX Subsection "sign_sig0"
\&\s-1SIG0\s0 support is provided through the Net::DNS::RR::SIG class.
This class is not integrated into Net::DNS but resides in the
Net::DNS::SEC distribution available from \s-1CPAN\s0.
.PP
.Vb 3
\&    $update = new Net::DNS::Update('example.com');
\&    $update->push( update => rr_add('foo.example.com A 10.1.2.3'));
\&    $update->sign_sig0('Kexample.com+003+25317.private');
.Ve
.PP
Execution will be terminated if Net::DNS::RR::SIG is not available.
.Sh "verify \s-1SIG0\s0"
.IX Subsection "verify SIG0"
.Vb 2
\&    $packet->verify( $keyrr )           || die $packet->verifyerr;
\&    $packet->verify( [$keyrr, ...] )    || die $packet->verifyerr;
.Ve
.PP
Verify \s-1SIG0\s0 packet signature against one or more specified \s-1KEY\s0 RRs.
.Sh "truncate"
.IX Subsection "truncate"
The truncate method takes a maximum length as argument and then tries
to truncate the packet and set the \s-1TC\s0 bit according to the rules of
\&\s-1RFC2181\s0 Section 9.
.PP
The minimum maximum length that is honoured is 512 octets.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2002 Michael Fuhr.
.PP
Portions Copyright (c)2002\-2004 Chris Reinhardt.
.PP
Portions Copyright (c)2002\-2009 Olaf Kolkman
.PP
Portions Copyright (c)2007\-2013 Dick Franks
.PP
All rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Update, Net::DNS::Header,
Net::DNS::Question, Net::DNS::RR, Net::DNS::RR::TSIG,
\&\s-1RFC1035\s0 Section 4.1, \s-1RFC2136\s0 Section 2, \s-1RFC2845\s0
