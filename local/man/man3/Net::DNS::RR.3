.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::RR 3"
.TH Net::DNS::RR 3 "2014-05-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Net::DNS::RR \- DNS Resource Record base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS;
.Ve
.PP
.Vb 1
\&    $rr = new Net::DNS::RR('example.com IN A 192.0.2.99');
.Ve
.PP
.Vb 5
\&    $rr = new Net::DNS::RR(
\&            name    => 'example.com',
\&            type    => 'A',
\&            address => '192.0.2.99'
\&            );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::DNS::RR is the base class for \s-1DNS\s0 Resource Record (\s-1RR\s0) objects.
See also the manual pages for each specific \s-1RR\s0 type.
.SH "METHODS"
.IX Header "METHODS"
\&\fB\s-1WARNING\s0!!!\fR  Do not assume the \s-1RR\s0 objects you receive from a query
are of a particular type \*(-- you must always check the object type
before calling any of its methods.  If you call an unknown method,
you will get an error message and execution will be terminated.
.Sh "new (from string)"
.IX Subsection "new (from string)"
.Vb 4
\&    $a     = new Net::DNS::RR('host.example.com. 86400 A 192.0.2.1');
\&    $mx    = new Net::DNS::RR('example.com. 7200 MX 10 mailhost.example.com.');
\&    $cname = new Net::DNS::RR('www.example.com 300 IN CNAME host.example.com');
\&    $txt   = new Net::DNS::RR('txt.example.com 3600 HS TXT "text data"');
.Ve
.PP
Returns an \s-1RR\s0 object of the appropriate type, or a \f(CW\*(C`Net::DNS::RR\*(C'\fR
object if the type is not implemented.	The attribute values are
extracted from the string passed by the user.  The syntax of the
argument string follows the \s-1RFC1035\s0 specification for zone files,
and is compatible with the result returned by the string method.
.PP
The name and \s-1RR\s0 type are required; all other information is optional.
If omitted, the \s-1TTL\s0 defaults to 0 and the \s-1RR\s0 class defaults to \s-1IN\s0.
Omitting the optional fields is useful for creating the empty \s-1RDATA\s0
sections required for certain dynamic update operations.  See the
\&\f(CW\*(C`Net::DNS::Update\*(C'\fR manual page for additional examples.
.PP
All names are interpreted as fully qualified domain names.
The trailing dot (.) is optional.
.Sh "new (from hash)"
.IX Subsection "new (from hash)"
.Vb 7
\&    $rr = new Net::DNS::RR(
\&            name    => 'host.example.com',
\&            ttl     => 86400,
\&            class   => 'IN',
\&            type    => 'A',
\&            address => '192.0.2.1'
\&            );
.Ve
.PP
.Vb 5
\&    $rr = new Net::DNS::RR(
\&            name    => 'txt.example.com',
\&            type    => 'TXT',
\&            txtdata => [ 'one', 'two' ]
\&            );
.Ve
.PP
Returns an \s-1RR\s0 object of the appropriate type, or a \f(CW\*(C`Net::DNS::RR\*(C'\fR
object if the type is not implemented.	See the manual pages for
each \s-1RR\s0 type to see what fields the type requires.
.PP
The \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`type\*(C'\fR fields are required; all others are optional.
If omitted, \f(CW\*(C`ttl\*(C'\fR defaults to 0 and \f(CW\*(C`class\*(C'\fR defaults to \s-1IN\s0.
Omitting the optional fields is useful for creating the empty \s-1RDATA\s0
sections required for certain dynamic update operations.
.Sh "decode"
.IX Subsection "decode"
.Vb 1
\&    ( $rr, $next ) = decode Net::DNS::RR( \e$data, $offset, @opaque );
.Ve
.PP
Decodes a \s-1DNS\s0 resource record at the specified location within a
\&\s-1DNS\s0 packet.
.PP
The argument list consists of a reference to the buffer containing
the packet data and offset indicating where resource record begins.
Remaining arguments, if any, are passed as opaque data to
subordinate decoders.
.PP
Returns a \f(CW\*(C`Net::DNS::RR\*(C'\fR object and the offset of the next record
in the packet.
.PP
An exception is raised if the data buffer contains insufficient or
corrupt data.
.PP
Any remaining arguments are passed as opaque data to subordinate
decoders and do not form part of the published interface.
.Sh "encode"
.IX Subsection "encode"
.Vb 1
\&    $data = $rr->encode( $offset, @opaque );
.Ve
.PP
Returns the \f(CW\*(C`Net::DNS::RR\*(C'\fR in binary format suitable for inclusion
in a \s-1DNS\s0 packet buffer.
.PP
The offset indicates the intended location within the packet data
where the \f(CW\*(C`Net::DNS::RR\*(C'\fR is to be stored.
.PP
Any remaining arguments are opaque data which are passed intact to
subordinate encoders.
.Sh "canonical"
.IX Subsection "canonical"
.Vb 1
\&    $data = $rr->canonical;
.Ve
.PP
Returns the \f(CW\*(C`Net::DNS::RR\*(C'\fR in canonical binary format suitable for
\&\s-1DNSSEC\s0 signature validation.
.PP
The absence of the associative array argument signals to subordinate
encoders that the canonical uncompressed lower case form of embedded
domain names is to be used.
.Sh "name"
.IX Subsection "name"
.Vb 1
\&    $name = $rr->name;
.Ve
.PP
Returns the owner name of the record.
.Sh "type"
.IX Subsection "type"
.Vb 1
\&    $type = $rr->type;
.Ve
.PP
Returns the record type.
.Sh "class"
.IX Subsection "class"
.Vb 1
\&    $class = $rr->class;
.Ve
.PP
Resource record class.
.Sh "ttl"
.IX Subsection "ttl"
.Vb 2
\&    $ttl = $rr->ttl;
\&    $ttl = $rr->ttl(3600);
.Ve
.PP
Resource record time to live in seconds.
.Sh "rdata"
.IX Subsection "rdata"
.Vb 1
\&    $rr = new Net::DNS::RR( type => NULL, rdata => 'arbitrary' );
.Ve
.PP
Resource record data section when viewed as opaque octets.
.Sh "print"
.IX Subsection "print"
.Vb 1
\&    $rr->print;
.Ve
.PP
Prints the record to the standard output.  Calls the \fBstring\fR
method to get the \s-1RR\s0 string representation.
.Sh "string"
.IX Subsection "string"
.Vb 1
\&    print $rr->string, "\en";
.Ve
.PP
Returns a string representation of the \s-1RR\s0 using the zone file format
described in \s-1RFC1035\s0.  All domain names are fully qualified with
trailing dot.  This differs from \s-1RR\s0 attribute methods, which omit
the trailing dot.
.Sh "rdstring"
.IX Subsection "rdstring"
.Vb 1
\&    $rdstring = $rr->rdstring;
.Ve
.PP
Returns a string representation of the RR-specific data.
.Sh "plain"
.IX Subsection "plain"
.Vb 1
\&    $plain = $rr->plain;
.Ve
.PP
Returns a simplified single line representation of the \s-1RR\s0 using the
zone file format defined in \s-1RFC1035\s0.  This facilitates interaction
with programs like nsupdate which have simplified \s-1RR\s0 parsers.
.Sh "token"
.IX Subsection "token"
.Vb 1
\&    @token = $rr->token;
.Ve
.PP
Returns a token list representation of the \s-1RR\s0 zone file string.
.SH "Sorting of RR arrays"
.IX Header "Sorting of RR arrays"
Sorting of \s-1RR\s0 arrays is done by \fINet::DNS::rrsort()\fR, see documentation
for Net::DNS. This package provides class methods to set the
comparator function used for a particular \s-1RR\s0 based on its attributes.
.Sh "set_rrsort_func"
.IX Subsection "set_rrsort_func"
.Vb 4
\&    Net::DNS::RR::MX->set_rrsort_func(
\&        'preference',
\&        sub { $Net::DNS::a->preference <=> $Net::DNS::b->preference }
\&        );
.Ve
.PP
.Vb 4
\&    Net::DNS::RR::MX->set_rrsort_func(
\&        'default_sort',
\&        Net::DNS::RR::MX->get_rrsort_func('preference')
\&        );
.Ve
.PP
\&\fIset_rrsort_func()\fR must be called as a class method. The first argument is
the attribute name on which the sorting is to take place. If you specify
\&\*(L"default_sort\*(R" then that is the sort algorithm that will be used when
\&\fIrrsort()\fR is called without an \s-1RR\s0 attribute as argument.
.PP
The second argument is a reference to a comparison function that uses the
global variables \f(CW$a\fR and \f(CW$b\fR in the Net::DNS package. During sorting, the
variables \f(CW$a\fR and \f(CW$b\fR will contain references to objects of the class whose
\&\fIset_rrsort_func()\fR was called. The above sorting function will only be
applied to Net::DNS::RR::MX objects.
.PP
The above example is the sorting function implemented in \s-1MX\s0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2002 Michael Fuhr. 
.PP
Portions Copyright (c)2002\-2004 Chris Reinhardt.
.PP
Portions Copyright (c)2005\-2007 Olaf Kolkman.
.PP
Portions Copyright (c)2007,2012 Dick Franks.
.PP
All rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Question,
Net::DNS::Packet, Net::DNS::Update,
\&\s-1RFC1035\s0 Section 4.1.3, \s-1RFC1123\s0, \s-1RFC3597\s0
