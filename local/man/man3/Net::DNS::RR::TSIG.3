.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DNS::RR::TSIG 3"
.TH Net::DNS::RR::TSIG 3 "2014-05-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Net::DNS::RR::TSIG \- DNS TSIG resource record
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Net::DNS;
\&    $tsig = create Net::DNS::RR::TSIG( $keyfile,
\&                                        fudge => 300
\&                                        );
.Ve
.PP
.Vb 1
\&    $tsig = create Net::DNS::RR::TSIG( $keyname, $key );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class for \s-1DNS\s0 Transaction Signature (\s-1TSIG\s0) resource records.
.SH "METHODS"
.IX Header "METHODS"
The available methods are those inherited from the base class augmented
by the type-specific methods defined in this package.
.PP
Use of undocumented package features or direct access to internal data
structures is discouraged and could result in program termination or
other unpredictable behaviour.
.Sh "algorithm"
.IX Subsection "algorithm"
.Vb 2
\&    $algorithm = $rr->algorithm;
\&    $rr->algorithm( $algorithm );
.Ve
.PP
A domain name which specifies the name of the algorithm.
.Sh "key"
.IX Subsection "key"
.Vb 1
\&    $rr->key( $key );
.Ve
.PP
Base64 representation of the key material.
.Sh "keybin"
.IX Subsection "keybin"
.Vb 1
\&    $rr->keybin( $keybin );
.Ve
.PP
Binary representation of the key material.
.Sh "time_signed"
.IX Subsection "time_signed"
.Vb 2
\&    $time_signed = $rr->time_signed;
\&    $rr->time_signed( $time_signed );
.Ve
.PP
Signing time as the number of seconds since 1 Jan 1970 00:00:00 \s-1UTC\s0.
The default signing time is the current time.
.Sh "fudge"
.IX Subsection "fudge"
.Vb 2
\&    $fudge = $rr->fudge;
\&    $rr->fudge( $fudge );
.Ve
.PP
\&\*(L"fudge\*(R" represents the permitted error in the signing time.
The default fudge is 300 seconds.
.Sh "mac"
.IX Subsection "mac"
.Vb 1
\&    $mac = $rr->mac;
.Ve
.PP
Returns the message authentication code (\s-1MAC\s0) as a string of hex
characters.  The programmer must call the Net::DNS::Packet \fIdata()\fR
object method before this will return anything meaningful.
.Sh "macbin"
.IX Subsection "macbin"
.Vb 2
\&    $macbin = $rr->macbin;
\&    $rr->macbin( $macbin );
.Ve
.PP
Binary message authentication code (\s-1MAC\s0).
.Sh "prior_mac"
.IX Subsection "prior_mac"
.Vb 2
\&    $prior_mac = $rr->prior_mac;
\&    $rr->prior_mac( $prior_mac );
.Ve
.PP
Prior message authentication code (\s-1MAC\s0).
.Sh "prior_macbin"
.IX Subsection "prior_macbin"
.Vb 2
\&    $prior_macbin = $rr->prior_macbin;
\&    $rr->prior_macbin( $prior_macbin );
.Ve
.PP
Binary prior message authentication code.
.Sh "request_mac"
.IX Subsection "request_mac"
.Vb 2
\&    $request_mac = $rr->request_mac;
\&    $rr->request_mac( $request_mac );
.Ve
.PP
Request message authentication code (\s-1MAC\s0).
.Sh "request_macbin"
.IX Subsection "request_macbin"
.Vb 2
\&    $request_macbin = $rr->request_macbin;
\&    $rr->request_macbin( $request_macbin );
.Ve
.PP
Binary request message authentication code.
.Sh "original_id"
.IX Subsection "original_id"
.Vb 2
\&    $original_id = $rr->original_id;
\&    $rr->original_id( $original_id );
.Ve
.PP
The message \s-1ID\s0 from the header of the original packet.
.Sh "error"
.IX Subsection "error"
.Vb 1
\&     $rcode = $tsig->error;
.Ve
.PP
Returns the \s-1RCODE\s0 covering \s-1TSIG\s0 processing.  Common values are
\&\s-1NOERROR\s0, \s-1BADSIG\s0, \s-1BADKEY\s0, and \s-1BADTIME\s0.  See \s-1RFC\s0 2845 for details.
.Sh "other"
.IX Subsection "other"
.Vb 2
\&    $other = $rr->other;
\&    $rr->other( $other );
.Ve
.PP
This field should be empty unless the error is \s-1BADTIME\s0, in which
case it will contain the server time as the number of seconds since
1 Jan 1970 00:00:00 \s-1UTC\s0.
.Sh "sig_function"
.IX Subsection "sig_function"
.Vb 2
\&    sub signing_function {
\&        my ( $keybin, $data ) = @_;
.Ve
.PP
.Vb 4
\&        my $hmac = new Digest::HMAC( $keybin, 'Digest::MD5' );
\&        $hmac->add( $data );
\&        return $hmac->digest;
\&    }
.Ve
.PP
.Vb 1
\&    $tsig->sig_function( \e&signing_function );
.Ve
.PP
This sets the signing function to be used for this \s-1TSIG\s0 record.
The default signing function is \s-1HMAC\-MD5\s0.
.Sh "sig_data"
.IX Subsection "sig_data"
.Vb 1
\&     $sigdata = $tsig->sig_data($packet);
.Ve
.PP
Returns the packet packed according to \s-1RFC2845\s0 in a form for signing. This
is only needed if you want to supply an external signing function, such as is
needed for \s-1TSIG\-GSS\s0.
.Sh "create"
.IX Subsection "create"
.Vb 1
\&    $tsig = create Net::DNS::RR::TSIG( $keyfile );
.Ve
.PP
.Vb 3
\&    $tsig = create Net::DNS::RR::TSIG( $keyfile,
\&                                        fudge => 300
\&                                        );
.Ve
.PP
.Vb 1
\&    $tsig = create Net::DNS::RR::TSIG( $keyname, $key );
.Ve
.PP
Returns a \s-1TSIG\s0 \s-1RR\s0 constructed using the parameters in the specified
key file, which is assumed to have been generated by dnssec\-keygen.
.PP
The two argument form is supported for backward compatibility.
.Sh "verify"
.IX Subsection "verify"
.Vb 2
\&    $verify = $tsig->verify( $data );
\&    $verify = $tsig->verify( $packet );
.Ve
.PP
.Vb 1
\&    $verify = $tsig->verify( $reply,  $query );
.Ve
.PP
.Vb 1
\&    $verify = $tsig->verify( $packet, $prior );
.Ve
.PP
The boolean verify method will return true if the hash over the
packet data conforms to the data in the \s-1TSIG\s0 itself
.SH "TSIG Keys"
.IX Header "TSIG Keys"
\&\s-1TSIG\s0 keys are symmetric keys generated using dnssec\-keygen:
.PP
.Vb 1
\&        $ dnssec-keygen -a HMAC-SHA1 -b 160 -n HOST <keyname>
.Ve
.PP
.Vb 2
\&        The key will be stored as a private and public keyfile pair
\&        K<keyname>+161+<keyid>.private and K<keyname>+161+<keyid>.key
.Ve
.PP
.Vb 2
\&    where
\&        <keyname> is the DNS name of the key.
.Ve
.PP
.Vb 2
\&        <keyid> is the (generated) numerical identifier used to
\&        distinguish this key.
.Ve
.PP
Other algorithms may be substituted for \s-1HMAC\-SHA1\s0 in the above example.
.PP
It is recommended that the keyname be globally unique and incorporate
the fully qualified domain names of the resolver and nameserver in
that order. It should be possible for more than one key to be in use
simultaneously between any such pair of hosts.
.PP
Although the formats differ, the private and public keys are identical
and both should be stored and handled as secret data.
.SH "Configuring BIND Nameserver"
.IX Header "Configuring BIND Nameserver"
The following lines must be added to the /etc/named.conf file:
.PP
.Vb 4
\&    key <keyname> {
\&        algorithm HMAC-SHA1;
\&        secret "<keydata>";
\&    };
.Ve
.PP
<keyname> is the name of the key chosen when the key was generated.
.PP
<keydata> is the key string extracted from the generated key file.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
Most of the code in the Net::DNS::RR::TSIG module was contributed
by Chris Turbeville. 
.PP
Support for external signing functions was added by Andrew Tridgell.
.PP
\&\s-1TSIG\s0 verification, \s-1BIND\s0 keyfile handling and support for \s-1HMAC\-SHA1\s0,
\&\s-1HMAC\-SHA224\s0, \s-1HMAC\-SHA256\s0, \s-1HMAC\-SHA384\s0 and \s-1HMAC\-SHA512\s0 functions was
added by Dick Franks.
.SH "BUGS"
.IX Header "BUGS"
A 32\-bit representation of time is used, contrary to \s-1RFC2845\s0 which
demands 48 bits.  This design decision will need to be reviewed
before the code stops working on 7 February 2106.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)2002 Michael Fuhr. 
.PP
Portions Copyright (c)2002\-2004 Chris Reinhardt.
.PP
Portions Copyright (c)2013 Dick Franks.
.PP
All rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
.PP
Package template (c)2009,2012 O.M.Kolkman and R.W.Franks.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::RR, \s-1RFC2845\s0, \s-1RFC4635\s0
