.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::Typemaps 3"
.TH ExtUtils::Typemaps 3 "2012-02-02" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
ExtUtils::Typemaps \- Read/Write/Modify Perl/XS typemap files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  # read/create file
\&  my $typemap = ExtUtils::Typemaps->new(file => 'typemap');
\&  # alternatively create an in-memory typemap
\&  # $typemap = ExtUtils::Typemaps->new();
\&  # alternatively create an in-memory typemap by parsing a string
\&  # $typemap = ExtUtils::Typemaps->new(string => $sometypemap);
.Ve
.PP
.Vb 10
\&  # add a mapping
\&  $typemap->add_typemap(ctype => 'NV', xstype => 'T_NV');
\&  $typemap->add_inputmap(
\&     xstype => 'T_NV', code => '$var = ($type)SvNV($arg);'
\&  );
\&  $typemap->add_outputmap(
\&     xstype => 'T_NV', code => 'sv_setnv($arg, (NV)$var);'
\&  );
\&  $typemap->add_string(string => $typemapstring);
\&                                           # will be parsed and merged
.Ve
.PP
.Vb 2
\&  # remove a mapping (same for remove_typemap and remove_outputmap...)
\&  $typemap->remove_inputmap(xstype => 'SomeType');
.Ve
.PP
.Vb 2
\&  # save a typemap to a file
\&  $typemap->write(file => 'anotherfile.map');
.Ve
.PP
.Vb 2
\&  # merge the other typemap into this one
\&  $typemap->merge(typemap => $another_typemap);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can read, modify, create and write Perl \s-1XS\s0 typemap files. If you don't know
what a typemap is, please confer the perlxstut and perlxs manuals.
.PP
The module is not entirely round-trip safe: For example it currently simply strips all comments.
The order of entries in the maps is, however, preserved.
.PP
We check for duplicate entries in the typemap, but do not check for missing
\&\f(CW\*(C`TYPEMAP\*(C'\fR entries for \f(CW\*(C`INPUTMAP\*(C'\fR or \f(CW\*(C`OUTPUTMAP\*(C'\fR entries since these might be hidden
in a different typemap.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
Returns a new typemap object. Takes an optional \f(CW\*(C`file\*(C'\fR parameter.
If set, the given file will be read. If the file doesn't exist, an empty typemap
is returned.
.PP
Alternatively, if the \f(CW\*(C`string\*(C'\fR parameter is given, the supplied
string will be parsed instead of a file.
.Sh "file"
.IX Subsection "file"
Get/set the file that the typemap is written to when the
\&\f(CW\*(C`write\*(C'\fR method is called.
.Sh "add_typemap"
.IX Subsection "add_typemap"
Add a \f(CW\*(C`TYPEMAP\*(C'\fR entry to the typemap.
.PP
Required named arguments: The \f(CW\*(C`ctype\*(C'\fR (e.g. \f(CW\*(C`ctype => 'double'\*(C'\fR)
and the \f(CW\*(C`xstype\*(C'\fR (e.g. \f(CW\*(C`xstype => 'T_NV'\*(C'\fR).
.PP
Optional named arguments: \f(CW\*(C`replace => 1\*(C'\fR forces removal/replacement of
existing \f(CW\*(C`TYPEMAP\*(C'\fR entries of the same \f(CW\*(C`ctype\*(C'\fR. \f(CW\*(C`skip => 1\*(C'\fR
triggers a \fI\*(L"first come first serve\*(R"\fR logic by which new entries that conflict
with existing entries are silently ignored.
.PP
As an alternative to the named parameters usage, you may pass in
an \f(CW\*(C`ExtUtils::Typemaps::Type\*(C'\fR object as first argument, a copy of which will be
added to the typemap. In that case, only the \f(CW\*(C`replace\*(C'\fR or \f(CW\*(C`skip\*(C'\fR named parameters
may be used after the object. Example:
.PP
.Vb 1
\&  $map->add_typemap($type_obj, replace => 1);
.Ve
.Sh "add_inputmap"
.IX Subsection "add_inputmap"
Add an \f(CW\*(C`INPUT\*(C'\fR entry to the typemap.
.PP
Required named arguments:
The \f(CW\*(C`xstype\*(C'\fR (e.g. \f(CW\*(C`xstype => 'T_NV'\*(C'\fR)
and the \f(CW\*(C`code\*(C'\fR to associate with it for input.
.PP
Optional named arguments: \f(CW\*(C`replace => 1\*(C'\fR forces removal/replacement of
existing \f(CW\*(C`INPUT\*(C'\fR entries of the same \f(CW\*(C`xstype\*(C'\fR. \f(CW\*(C`skip => 1\*(C'\fR
triggers a \fI\*(L"first come first serve\*(R"\fR logic by which new entries that conflict
with existing entries are silently ignored.
.PP
As an alternative to the named parameters usage, you may pass in
an \f(CW\*(C`ExtUtils::Typemaps::InputMap\*(C'\fR object as first argument, a copy of which will be
added to the typemap. In that case, only the \f(CW\*(C`replace\*(C'\fR or \f(CW\*(C`skip\*(C'\fR named parameters
may be used after the object. Example:
.PP
.Vb 1
\&  $map->add_inputmap($type_obj, replace => 1);
.Ve
.Sh "add_outputmap"
.IX Subsection "add_outputmap"
Add an \f(CW\*(C`OUTPUT\*(C'\fR entry to the typemap.
Works exactly the same as \f(CW\*(C`add_inputmap\*(C'\fR.
.Sh "add_string"
.IX Subsection "add_string"
Parses a string as a typemap and merge it into the typemap object.
.PP
Required named argument: \f(CW\*(C`string\*(C'\fR to specify the string to parse.
.Sh "remove_typemap"
.IX Subsection "remove_typemap"
Removes a \f(CW\*(C`TYPEMAP\*(C'\fR entry from the typemap.
.PP
Required named argument: \f(CW\*(C`ctype\*(C'\fR to specify the entry to remove from the typemap.
.PP
Alternatively, you may pass a single \f(CW\*(C`ExtUtils::Typemaps::Type\*(C'\fR object.
.Sh "remove_inputmap"
.IX Subsection "remove_inputmap"
Removes an \f(CW\*(C`INPUT\*(C'\fR entry from the typemap.
.PP
Required named argument: \f(CW\*(C`xstype\*(C'\fR to specify the entry to remove from the typemap.
.PP
Alternatively, you may pass a single \f(CW\*(C`ExtUtils::Typemaps::InputMap\*(C'\fR object.
.Sh "remove_inputmap"
.IX Subsection "remove_inputmap"
Removes an \f(CW\*(C`OUTPUT\*(C'\fR entry from the typemap.
.PP
Required named argument: \f(CW\*(C`xstype\*(C'\fR to specify the entry to remove from the typemap.
.PP
Alternatively, you may pass a single \f(CW\*(C`ExtUtils::Typemaps::OutputMap\*(C'\fR object.
.Sh "get_typemap"
.IX Subsection "get_typemap"
Fetches an entry of the \s-1TYPEMAP\s0 section of the typemap.
.PP
Mandatory named arguments: The \f(CW\*(C`ctype\*(C'\fR of the entry.
.PP
Returns the \f(CW\*(C`ExtUtils::Typemaps::Type\*(C'\fR
object for the entry if found.
.Sh "get_inputmap"
.IX Subsection "get_inputmap"
Fetches an entry of the \s-1INPUT\s0 section of the
typemap.
.PP
Mandatory named arguments: The \f(CW\*(C`xstype\*(C'\fR of the
entry or the \f(CW\*(C`ctype\*(C'\fR of the typemap that can be used to find
the \f(CW\*(C`xstype\*(C'\fR. To wit, the following pieces of code
are equivalent:
.PP
.Vb 2
\&  my $type = $typemap->get_typemap(ctype => $ctype)
\&  my $input_map = $typemap->get_inputmap(xstype => $type->xstype);
.Ve
.PP
.Vb 1
\&  my $input_map = $typemap->get_inputmap(ctype => $ctype);
.Ve
.PP
Returns the \f(CW\*(C`ExtUtils::Typemaps::InputMap\*(C'\fR
object for the entry if found.
.Sh "get_outputmap"
.IX Subsection "get_outputmap"
Fetches an entry of the \s-1OUTPUT\s0 section of the
typemap.
.PP
Mandatory named arguments: The \f(CW\*(C`xstype\*(C'\fR of the
entry or the \f(CW\*(C`ctype\*(C'\fR of the typemap that can be used to
resolve the \f(CW\*(C`xstype\*(C'\fR. (See above for an example.)
.PP
Returns the \f(CW\*(C`ExtUtils::Typemaps::InputMap\*(C'\fR
object for the entry if found.
.Sh "write"
.IX Subsection "write"
Write the typemap to a file. Optionally takes a \f(CW\*(C`file\*(C'\fR argument. If given, the
typemap will be written to the specified file. If not, the typemap is written
to the currently stored file name (see \f(CW\*(C`\->file\*(C'\fR above, this defaults to the file
it was read from if any).
.Sh "as_string"
.IX Subsection "as_string"
Generates and returns the string form of the typemap.
.Sh "as_embedded_typemap"
.IX Subsection "as_embedded_typemap"
Generates and returns the string form of the typemap with the
appropriate prefix around it for verbatim inclusion into an
\&\s-1XS\s0 file as an embedded typemap. This will return a string like
.PP
.Vb 3
\&  TYPEMAP: <<END_OF_TYPEMAP
\&  ... typemap here (see as_string) ...
\&  END_OF_TYPEMAP
.Ve
.PP
The method takes care not to use a HERE-doc end marker that
appears in the typemap string itself.
.Sh "merge"
.IX Subsection "merge"
Merges a given typemap into the object. Note that a failed merge
operation leaves the object in an inconsistent state so clone it if necessary.
.PP
Mandatory named arguments: Either \f(CW\*(C`typemap => $another_typemap_obj\*(C'\fR
or \f(CW\*(C`file => $path_to_typemap_file\*(C'\fR but not both.
.PP
Optional arguments: \f(CW\*(C`replace => 1\*(C'\fR to force replacement
of existing typemap entries without warning or \f(CW\*(C`skip => 1\*(C'\fR
to skip entries that exist already in the typemap.
.Sh "is_empty"
.IX Subsection "is_empty"
Returns a bool indicating whether this typemap is entirely empty.
.Sh "list_mapped_ctypes"
.IX Subsection "list_mapped_ctypes"
Returns a list of the C types that are mappable by
this typemap object.
.Sh "_get_typemap_hash"
.IX Subsection "_get_typemap_hash"
Returns a hash mapping the C types to the \s-1XS\s0 types:
.PP
.Vb 8
\&  {
\&    'char **' => 'T_PACKEDARRAY',
\&    'bool_t' => 'T_IV',
\&    'AV *' => 'T_AVREF',
\&    'InputStream' => 'T_IN',
\&    'double' => 'T_DOUBLE',
\&    # ...
\&  }
.Ve
.PP
This is documented because it is used by \f(CW\*(C`ExtUtils::ParseXS\*(C'\fR,
but it's not intended for general consumption. May be removed
at any time.
.Sh "_get_inputmap_hash"
.IX Subsection "_get_inputmap_hash"
Returns a hash mapping the \s-1XS\s0 types (identifiers) to the
corresponding \s-1INPUT\s0 code:
.PP
.Vb 8
\&  {
\&    'T_CALLBACK' => '   $var = make_perl_cb_$type($arg)
\&  ',
\&    'T_OUT' => '    $var = IoOFP(sv_2io($arg))
\&  ',
\&    'T_REF_IV_PTR' => '   if (sv_isa($arg, \e\e"${ntype}\e\e")) {
\&    # ...
\&  }
.Ve
.PP
This is documented because it is used by \f(CW\*(C`ExtUtils::ParseXS\*(C'\fR,
but it's not intended for general consumption. May be removed
at any time.
.Sh "_get_outputmap_hash"
.IX Subsection "_get_outputmap_hash"
Returns a hash mapping the \s-1XS\s0 types (identifiers) to the
corresponding \s-1OUTPUT\s0 code:
.PP
.Vb 17
\&  {
\&    'T_CALLBACK' => '   sv_setpvn($arg, $var.context.value().chp(),
\&                $var.context.value().size());
\&  ',
\&    'T_OUT' => '    {
\&            GV *gv = newGVgen("$Package");
\&            if ( do_open(gv, "+>&", 3, FALSE, 0, 0, $var) )
\&                sv_setsv(
\&                  $arg,
\&                  sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1))
\&                );
\&            else
\&                $arg = &PL_sv_undef;
\&         }
\&  ',
\&    # ...
\&  }
.Ve
.PP
This is documented because it is used by \f(CW\*(C`ExtUtils::ParseXS\*(C'\fR,
but it's not intended for general consumption. May be removed
at any time.
.Sh "_get_prototype_hash"
.IX Subsection "_get_prototype_hash"
Returns a hash mapping the C types of the typemap to their
corresponding prototypes.
.PP
.Vb 8
\&  {
\&    'char **' => '$',
\&    'bool_t' => '$',
\&    'AV *' => '$',
\&    'InputStream' => '$',
\&    'double' => '$',
\&    # ...
\&  }
.Ve
.PP
This is documented because it is used by \f(CW\*(C`ExtUtils::ParseXS\*(C'\fR,
but it's not intended for general consumption. May be removed
at any time.
.SH "CAVEATS"
.IX Header "CAVEATS"
Inherits some evil code from \f(CW\*(C`ExtUtils::ParseXS\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The parser is heavily inspired from the one in ExtUtils::ParseXS.
.PP
For details on typemaps: perlxstut, perlxs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steffen Mueller \f(CW\*(C`<smueller@cpan.org\*(C'\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009, 2010, 2011, 2012 Steffen Mueller
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
