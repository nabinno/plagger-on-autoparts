.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Auto 3"
.TH Config::Auto 3 "2012-02-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Config::Auto \- Magical config file parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Auto;
.Ve
.PP
.Vb 2
\&    ### Not very magical at all.
\&    $config = Config::Auto::parse("myprogram.conf", format => "colon");
.Ve
.PP
.Vb 2
\&    ### Considerably more magical.
\&    $config = Config::Auto::parse("myprogram.conf");
.Ve
.PP
.Vb 2
\&    ### Highly magical.
\&    $config = Config::Auto::parse();
.Ve
.PP
.Vb 4
\&    ### Using the OO interface
\&    $ca     = Config::Auto->new( source => $text );
\&    $ca     = Config::Auto->new( source => $fh );
\&    $ca     = Config::Auto->new( source => $filename );
.Ve
.PP
.Vb 1
\&    $href   = $ca->score;           # compute the score for various formats
.Ve
.PP
.Vb 1
\&    $config = $ca->parse;           # parse the config
.Ve
.PP
.Vb 5
\&    $format = $ca->format;          # detected (or provided) config format
\&    $str    = $ca->as_string;       # config file stringified
\&    $fh     = $ca->fh;              # config file handle
\&    $file   = $ca->file;            # config filename
\&    $aref   = $ca->data;            # data from your config, split by newlines
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module was written after having to write Yet Another Config File Parser
for some variety of colon-separated config. I decided \*(L"never again\*(R".
.PP
Config::Auto aims to be the most \f(CW\*(C`DWIM\*(C'\fR config parser available, by detecting
configuration styles, include paths and even config filenames automagically.
.PP
See the \*(L"\s-1HOW\s0 \s-1IT\s0 \s-1WORKS\s0\*(R" section below on implementation details.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.Sh "@formats = Config::Auto\->formats"
.IX Subsection "@formats = Config::Auto->formats"
Returns a list of supported formats for your config files. These formats
are also the keys as used by the \f(CW\*(C`score()\*(C'\fR method.
.PP
\&\f(CW\*(C`Config::Auto\*(C'\fR recognizes the following formats:
.IP "* perl    => perl code" 4
.IX Item "perl    => perl code"
.PD 0
.IP "* colon   => colon separated (e.g., key:value)" 4
.IX Item "colon   => colon separated (e.g., key:value)"
.IP "* space   => space separated (e.g., key value)" 4
.IX Item "space   => space separated (e.g., key value)"
.IP "* equal   => equal separated (e.g., key=value)" 4
.IX Item "equal   => equal separated (e.g., key=value)"
.IP "* bind    => bind style (not available)" 4
.IX Item "bind    => bind style (not available)"
.IP "* irssi   => irssi style (not available)" 4
.IX Item "irssi   => irssi style (not available)"
.IP "* xml     => xml (via XML::Simple)" 4
.IX Item "xml     => xml (via XML::Simple)"
.IP "* ini     => .ini format (via Config::IniFiles)" 4
.IX Item "ini     => .ini format (via Config::IniFiles)"
.IP "* list    => list (e.g., foo bar baz)" 4
.IX Item "list    => list (e.g., foo bar baz)"
.IP "* yaml    => yaml (via \s-1YAML\s0.pm)" 4
.IX Item "yaml    => yaml (via YAML.pm)"
.PD
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh "$obj = Config::Auto\->new( [source => $text|$fh|$filename, path => \e@paths, format => \s-1FORMAT_NAME\s0] );"
.el .Sh "$obj = Config::Auto\->new( [source => \f(CW$text\fP|$fh|$filename, path => \e@paths, format => \s-1FORMAT_NAME\s0] );"
.IX Subsection "$obj = Config::Auto->new( [source => $text|$fh|$filename, path => @paths, format => FORMAT_NAME] );"
Returns a \f(CW\*(C`Config::Auto\*(C'\fR object based on your configs source. This can either be:
.IP "a filehandle" 4
.IX Item "a filehandle"
Any opened filehandle, or \f(CW\*(C`IO::Handle\*(C'\fR/\f(CW\*(C`IO::String\*(C'\fR object.
.IP "a plain text string" 4
.IX Item "a plain text string"
Any plain string containing one or more newlines.
.IP "a filename" 4
.IX Item "a filename"
Any plain string pointing to a file on disk
.IP "nothing" 4
.IX Item "nothing"
A heuristic will be applied to find your config file, based on the name of
your script; \f(CW$0\fR.
.PP
Although \f(CW\*(C`Config::Auto\*(C'\fR is at its most magical when called with no parameters,
its behavior can be controlled explicitly by using one or two arguments.
.PP
If a filename is passed as the \f(CW\*(C`source\*(C'\fR argument, the same paths are checked,
but \f(CW\*(C`Config::Auto\*(C'\fR will look for a file with the passed name instead of the
\&\f(CW$0\fR\-based names.
.PP
Supplying the \f(CW\*(C`path\*(C'\fR parameter will add additional directories to the search
paths. The current directory is searched first, then the paths specified with
the path parameter. \f(CW\*(C`path\*(C'\fR can either be a scalar or a reference to an array
of paths to check.
.PP
The \f(CW\*(C`format\*(C'\fR parameters forces \f(CW\*(C`Config::Auto\*(C'\fR to interpret the contents of
the configuration file in the given format without trying to guess.
.ie n .Sh "$rv = $obj\->parse | Config::Auto::parse( [$text|$fh|$filename, path => \e@paths, format => \s-1FORMAT_NAME\s0] );"
.el .Sh "$rv = \f(CW$obj\fP\->parse | Config::Auto::parse( [$text|$fh|$filename, path => \e@paths, format => \s-1FORMAT_NAME\s0] );"
.IX Subsection "$rv = $obj->parse | Config::Auto::parse( [$text|$fh|$filename, path => @paths, format => FORMAT_NAME] );"
Parses the source you provided in the \f(CW\*(C`new()\*(C'\fR call and returns a data
structure representing your configuration file.
.PP
You can also call it in a procedural context (\f(CW\*(C`Config::Auto::parse()\*(C'\fR), where
the first argument is the source, and the following arguments are named. This
function is provided for backwards compatiblity with releases prior to 0.29.
.ie n .Sh "$href = $obj\->score;"
.el .Sh "$href = \f(CW$obj\fP\->score;"
.IX Subsection "$href = $obj->score;"
Takes a look at the contents of your configuration data and produces a
\&'score' determining which format it most likely contains.
.PP
They keys are equal to formats as returned by the \f(CW\*(C`Config::Auto\->formats\*(C'\fR
and their values are a score between 1 and 100. The format with the highest
score will be used to parse your configuration data, unless you provided the
\&\f(CW\*(C`format\*(C'\fR option explicitly to the \f(CW\*(C`new()\*(C'\fR method.
.ie n .Sh "$aref = $obj\->data;"
.el .Sh "$aref = \f(CW$obj\fP\->data;"
.IX Subsection "$aref = $obj->data;"
Returns an array ref of your configuration data, split by newlines.
.ie n .Sh "$fh = $obj\->fh;"
.el .Sh "$fh = \f(CW$obj\fP\->fh;"
.IX Subsection "$fh = $obj->fh;"
Returns a filehandle, opened for reading, containing your configuration
data. This works even if you provided a plain text string or filename to
parse.
.ie n .Sh "$filename = $obj\->file;"
.el .Sh "$filename = \f(CW$obj\fP\->file;"
.IX Subsection "$filename = $obj->file;"
Returns a filename containing your configuration data. This works even
if you provided a plaintext string or filehandle to parse. In that case,
a temporary file will be written holding your configuration data.
.ie n .Sh "$str = $obj\->as_string;"
.el .Sh "$str = \f(CW$obj\fP\->as_string;"
.IX Subsection "$str = $obj->as_string;"
Returns a string representation of your configuration data.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
\fI$DisablePerl\fR
.IX Subsection "$DisablePerl"
.PP
Set this variable to true if you do not wish to \f(CW\*(C`eval\*(C'\fR perl style configuration
files.
.PP
Default is \f(CW\*(C`false\*(C'\fR
.PP
\fI$Untaint\fR
.IX Subsection "$Untaint"
.PP
Set this variable to true if you automatically want to untaint values obtained
from a perl style configuration. See \*(L"perldoc perlsec\*(R" for details on tainting.
.PP
Default is \f(CW\*(C`false\*(C'\fR
.PP
\fI$Debug\fR
.IX Subsection "$Debug"
.PP
Set this variable to true to get extra debug information from \f(CW\*(C`Config::Auto\*(C'\fR
when finding and/or parsing config files fails.
.PP
Default is \f(CW\*(C`false\*(C'\fR
.SH "HOW IT WORKS"
.IX Header "HOW IT WORKS"
When you call \f(CW\*(C`Config::Auto\->new\*(C'\fR or \f(CW\*(C`Config::Auto::parse\*(C'\fR with no
arguments, we first look at \f(CW$0\fR to determine the program's name. Let's
assume that's \f(CW\*(C`snerk\*(C'\fR. We look for the following files:
.PP
.Vb 4
\&    snerkconfig
\&    ~/snerkconfig
\&    /etc/snerkconfig
\&    /usr/local/etc/snerkconfig
.Ve
.PP
.Vb 4
\&    snerk.config
\&    ~/snerk.config
\&    /etc/snerk.config
\&    /usr/local/etc/snerk.config
.Ve
.PP
.Vb 4
\&    snerkrc
\&    ~/snerkrc
\&    /etc/snerkrc
\&    /usr/local/etc/snerkrc
.Ve
.PP
.Vb 4
\&    .snerkrc
\&    ~/.snerkrc
\&    /etc/.snerkrc
\&    /usr/local/etc/.snerkrc
.Ve
.PP
Additional search paths can be specified with the \f(CW\*(C`path\*(C'\fR option.
.PP
We take the first one we find, and examine it to determine what format
it's in. The algorithm used is a heuristic \*(L"which is a fancy way of
saying that it doesn't work.\*(R" (Mark Dominus.) We know about colon
separated, space separated, equals separated, \s-1XML\s0, Perl code, Windows
\&\s-1INI\s0, \s-1BIND9\s0 and irssi style config files. If it chooses the wrong one,
you can force it with the \f(CW\*(C`format\*(C'\fR option.
.PP
If you don't want it ever to detect and execute config files which are made
up of Perl code, set \f(CW\*(C`$Config::Auto::DisablePerl = 1\*(C'\fR.
.PP
When using the perl format, your configuration file will be eval'd. This will
cause taint errors. To avoid these warnings, set \f(CW\*(C`$Config::Auto::Untaint = 1\*(C'\fR.
This setting will not untaint the data in your configuration file and should only
be used if you trust the source of the filename.
.PP
Then the file is parsed and a data structure is returned. Since we're
working magic, we have to do the best we can under the circumstances \-
\&\*(L"You rush a miracle man, you get rotten miracles.\*(R" (Miracle Max) So
there are no guarantees about the structure that's returned. If you have
a fairly regular config file format, you'll get a regular data
structure back. If your config file is confusing, so will the return
structure be. Isn't life tragic?
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here's what we make of some common Unix config files:
.PP
\&\fI/etc/resolv.conf\fR:
.PP
.Vb 4
\&    $VAR1 = {
\&        'nameserver' => [ '163.1.2.1', '129.67.1.1', '129.67.1.180' ],
\&        'search' => [ 'oucs.ox.ac.uk', 'ox.ac.uk' ]
\&    };
.Ve
.PP
\&\fI/etc/passwd\fR:
.PP
.Vb 4
\&    $VAR1 = {
\&        'root' => [ 'x', '0', '0', 'root', '/root', '/bin/bash' ],
\&        ...
\&    };
.Ve
.PP
\&\fI/etc/gpm.conf\fR:
.PP
.Vb 7
\&    $VAR1 = {
\&        'append' => '""',
\&        'responsiveness' => '',
\&        'device' => '/dev/psaux',
\&        'type' => 'ps2',
\&        'repeat_type' => 'ms3'
\&    };
.Ve
.PP
\&\fI/etc/nsswitch.conf\fR:
.PP
.Vb 6
\&    $VAR1 = {
\&        'netgroup' => 'nis',
\&        'passwd' => 'compat',
\&        'hosts' => [ 'files', 'dns' ],
\&        ...
\&    };
.Ve
.SH "MEMORY USAGE"
.IX Header "MEMORY USAGE"
This module is as light as possible on memory, only using modules when they
are absolutely needed for configuration file parsing.
.SH "TROUBLESHOOTING"
.IX Header "TROUBLESHOOTING"
.IP "When using a Perl config file, the configuration is borked" 4
.IX Item "When using a Perl config file, the configuration is borked"
Give \f(CW\*(C`Config::Auto\*(C'\fR more hints (e.g., add #!/usr/bin/perl to beginning of
file) or indicate the format in the \f(CW\*(C`new\*(C'\fR/\f(CW\*(C`parse()\*(C'\fR command.
.SH "TODO"
.IX Header "TODO"
\&\s-1BIND9\s0 and irssi file format parsers currently don't exist. It would be
good to add support for \f(CW\*(C`mutt\*(C'\fR and \f(CW\*(C`vim\*(C'\fR style \f(CW\*(C`set\*(C'\fR\-based RCs.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-config\-auto@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Versions 0.04 and higher of this module by Jos Boumans <kane@cpan.org>.
.PP
This module originally by Simon Cozens.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
